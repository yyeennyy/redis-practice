## 개념
---
### 1. 구조  
publisher → 메시지 전달 → redis(broker)  
subscriber ← 메시지 발행 ← redis(broker)  

<br>

### 2. 장단점
- 느슨한 결합: 수신 서버와 발행 서버는 서로 신경쓰지 않아도 됩니다. 수신 서버 개수가 증가해도, 발행자는 아무 신경 쓰지 않고 발행하면 됩니다. 그저 redis(broker) 에게만 메시지를 전달하면 됩니다. 만약 redis가 없고 서버 to 서버로 연결된 구조에서는 수신자 개수가 늘어나면 소스코드를 수정해야 합니다!

- 인메모리: 실시간 처리량에 이점이 있습니다. 그러나 가용성 및 대량 처리는 약점! 더욱 고도화된 kafka를 사용을 권장합니다. 만약 redis 서버가 다운된 후 다시 연결되면, 기존 메시지들은 휘발된다는 것을 꼭 기억합시다.  

<br>

### 3. 간단 예제 (publish & subscribe)
- 준비물: 터미널 두개
- 내용: 발행과 구독을 간단 실습해보자


    |subscriber|publisher|
    |------|---|
    |redis> subscribe users:1<br>-- 블로킹되면서 메시지를 기다리는 중 --||
    |-- 블로킹되면서 메시지를 기다리는 중 --||
    |-- 블로킹되면서 메시지를 기다리는 중 --||
    |"message"<br>"users:1"<br>"hihi"|redis> publish users:1 hihi<br><br><br>|
    |-- 블로킹되면서 메시지를 기다리는 중 --||
    |"message"<br>"users:1"<br>"^o^*"|redis> publish users:1 ^o^*<br><br><br>|

<br>

### 4. 이 구조의 활용처  
  - 이벤트 전달 (ex: '상품구매' 이벤트 발행하면, 상품발행을 구독하는 서비스 존재 / '탈퇴' 이벤트 발행하면, '탈퇴'를 구독하는 서비스가 데이터 삭제처리 등 )
  - 실시간 채팅, 라이브 피드 (pub/sub + websocket) 
  - 로컬 캐시 갱신 (분리된 인스턴스간 evict는 까다로운데, pub/sub을 활용하여 evict 신호를 주고 받기 좋다)
  - 앱 푸시 알림